125)from dev to prod.
    see slide 2
    things to keep in mind -
        1) for bind mounts even though we may use them during development and we shouldn't use them in production.You will still learn
         in this section how does won't contradict the idea behind containers and how does won't lead to containers that are different 
         during development and production.
        
        2)your containerized apps might need different setups for development and for production which sounds strange at first
            after all the idea with containers was that we have one at the same environment.That's true but some applications
            like React apps for example simply need a build step where the code is converted and optimized and that builds step
            happens after development before you deploy the application.But even though we need this build step in this module
            you will all learn how you can still ensure that you ship containers which have reproducible environments and where 
            to code that work locally will also work once you deployed it

        3)So whilst you might be able to test everything let's say with Docker compose locally on one host machine for deployment you
         might consider splitting it across multiple servers or multiple host machines

        4)couple of lectures in this module where we will actually go for less control but also less responsibilities solution
            so that ultimately we as a developer have an easier time.


126)deployment processes and examples
    here we will deploy a simple nodejs application woth database to EC2 in aws.
    refer slide 4
        hosting provider - remote machine.


127)here we deploy a node js app without db into EC2.EC2 is a service offered by AWS which allows you to spin up your own remote hosting
    machines, you could say,Your own computers in the cloud.
    And we will go though three main steps to bring our Dockerized application to life on an EC2 instance.
        refer slide 6

    refer to code1 foler. first we build the image -
        docker build -t node-dep-example .

    then we run the container based on that image -

        docker run -d --rm --name node-dep -p 80:80 node-dep-example

128)bind mounts in prod
    refer slide 3. 
    while running container we did'nt specified any bind mounds infact we didi not use any volumes.

    In development so whilst we're working on the application,our container of course should encapsulate the runtime environment,but not 
    and that's important, not necessarily the code.

    In Prod ,There the idea really is that the container works standalone and that it does not depend on any surrounding setup on the 
    remote machine.The image and therefore the container based on the image should be the single source of truth you could say.That means
    we can rely on the fact that if we take that image and run a container based on it,we got everything this application needs.We don't 
    also need to move some source code into a special folder on that remote machine.That would totally destroy the idea behind containers
    if we now all of a sudden again need to configure the hosting machine.We want to have everything,what our application needs inside of
    that container.There should be nothing, absolutely nothing,around that container on the hosting machine.And therefore when we build for
    production,we use copy instead of bind mounts.


    now we specify bind mounts and volumnes while running a container based on a image. thsi helps us to use same docker imge in dev and
    prod, its just while running container for dev we can use bind mounts. this is the reason why bind mounts an dvolumes are not part of
    dockerFile.


    Now of course if we used a Docker compose file,we might have that bind mount written into that compose file,but I will come back to 
    compose files and how we deploy such multi container projects later.For the moment it's about one container, one image and then copy
    is your friend


129)Introducing AWS & EC2
    EC2 allows us to create virtual servers in cloud which means our own computers in cloud.  
    1)go to aws management console.
    2)search Ec2 and clicked on it.
    3)now goal is to start a Ec2 instance, there are multiplw ways of doing it.one is to click on "Launch Instance".

130)Connecting to an EC2 instance
    1)here we configure our instance that we are going to launch. 
    2)important screen is keypair.Here you can create a new key pair and you will need this key pair,which will be a file in the end,to 
        later connect to your instance via SSH and to run commands on it. so created a key pair and gave it name example-1.
    3)after creating key-pair, we clicked on Luanch instance.
    4)click on "view all instances".
    5)status of your instnace your be running.
    6)now we need to connect to this server using ssh.
        a)for mac and linux - 
            you can directly use ssh command in terminal.
        b)for windows this is not build it .
            a)you need to instal wsl2 on widnows 10(linux running for windows) or putty.

    7)select instnace and click on connect and select ssh. here follow the steps given in to connect to server.
    8)now we are connected to remote server.

131)Installing docker
    updating packages -
        sudo yum update -y
            this will update all packages. then run this -

    installing docker -
        sudo amazon-linux-extras install docker

        that's why we should pick this amaxon image when we created this instance.on this amazozn based virtual instances,we have these commands 
        avalible which makes installing these extra softwares like docker easier. this will install docker on remote machine.

    starting docker -
        sudo service docker start
        now docker is started and we can run docker commands.


133)pushing image to cloud
    here we pushed our image to docker hub. first we create a new repo on docker hub. then we created a image on local system. then we
    renamed that image to same name as docker hub repository -
        docker tag existingImageName nameformDockerHub
    
     then we ran  -
        docker push sumeet27/node-example-1

    you should be logged in to docker.you can use this command to login -
        docker login

134)RUNNING & PUBLISHING the app(on EC2)

    sudo docker run -d --rm -p 80:80 sumeet27/node-example-1





