181)Kubernetes in Action - Diving into Core concepts
    ways to create infrastruture for kubernetes -
        
        a)kubermatic - built for kubernetes but not part of it
        
        b)elastic kubrnetes service (EKS) - That is a service which will allow you to bring your own Kubernetes configuration so that you
        don't have to use the AWS specific configuration as you did have to use with ECS but EKS. So this Elastic Kubernetes Service will
        then also set up all the resources neededby your Kubernetes configuration.


182)Kubenetes: Required Setup and installiyion steps

    refer slide 2

    things we need to get started -

        1)Cluster - Master and Worker Node, all softwares and services installed on them.
        
        2)kubectl or kube-control tool - we need another tool locally on our machine and that's the kubectl or kube-control tool. The 
            kubectl tool is actually a tool which you then use to send instructions to the cluster for example, to create a new deployment,
            delete a deployment or change our running deployment. kebectl sends instructions to master node, which in turn sends 
            instruction to slave node.


    Mincube -
        And for setting up this dummy cluster locally we can use a tool called minikube. Minikube is in the end a tool which you can 
        install locally for playing around with Kubernetes and for testing it and it will use a virtual machine on your laptop on your
        machine, on your local machine to create the cluster in there.So it simulates another machine on your machine by using such a
        virtual machine and the this virtual machine then holds this cluster.


        It will actually create a single node cluster which means there the worker and master node is combined into one single virtual 
        machine, this is not someting we do in deployment bit here it is fine.


183)MacOs setup
    see Kubenetes commands notes.

    here we installed minikube and kubectl. then we started our cluster by - minikube start

184)Windows setup

185)Understanding Kubernetes Object(Resources)
    slide3
    
    now we need to understand which kind of commands, which kind of language Kubernetes understands,for example,create a new pod and 
    start a new container.Kubernetes works with so called objects.Kubernetes knows a couple of objects, for example, pods, deployments,
    services, volumes,and way more than that.

    Now, the idea behind these objects,is simply that you can create such an object by executing a certain command.And then Kubernetes 
    will take that object created by you,which of course is just a thing in code in the end,and it will then do something based on the
    instructions encoded in that object, you could say.And these objects can actually be created in two different ways, 
    
        1)imperatively
        2)declaratively.

    Some key object kubernenets knows(slide 4) -

    a)Pods - If you wanna tell Kubernetes,that it should create a pod,run a container and do that on some worker node in the cluster.
        You would tell Kubernetes to do that,by creating a pod object in code or with help of a command,and sending that object to 
        Kubernetes. pods are part of cluster therefore can commnunicate with other pods outside world.by default pod has cluster-internal
        IP by default. we can chnage this and communicate with cluster even from outside the cluster.But by default, a pod has a cluster
        internal IP address,which can be used to send requests to that pod and there for to the containers running in the pod. containers
        inside same pod can communicate with each other with local host.

    important things about pods -
        1)pods are ephemeral,which basically means they don't persist.If a pod is replaced or removed by Kubernetes,all the resources in 
            the pod,for example, data stored and created by a container is lost.

        2)when working with Kubernetes,we can create pods on our own and start them on some worker node in our cluster,but that's typically
            not what we will do.Instead, we want Kubernetes to manage these pods for us,We want Kubernetes to automatically create and 
            remove and replace them.
            
        And that's why we typically don't just create pod objects and send them to the cluster,but why we create controller objects,
            specifically the deployment object,which then actually will create pods for us.So therefore, let's next have a look at this
            deployment object, and let's understand how that works.



186)The "Deployment" object
    we genrally do not create pod objects but we create deployment objects. see slide 5.

187)A First Deployment
    here we wanted to deploy code1 in kubernetes cluster.
    1)create docker image -
        docker build -t kub-first-app

    2)start kubernetes cluster , if it is not already running -
        minikube status (checks status)
        minikube start (starts cluster, needed if cluster is not running)

    3)we can now send our image or send the instruction to create a deployment to that cluster.we use kubectl command to create deployment
        object. with create command object is automatically created and sent to cluster. so we use kubectl create command to create 
        deployment object, this is imperative way of creating the objects.

        kubectl create typeofObject nameOfObject --image=nameOfImageUsedByContainerOfPodCreatedByThisDeployment
        kubectl create deployment first-app --image="kub-first-app"

        you will not get error here but this will not check. lets check how many deployment are in lcuster to which we are connected -

            kubectl get deployments

        By the way, kubectl was configured by minikube automatically connect to minikube so we don't need to tell the command that we
        wanna interact with minikube here. we see we have 1 deploymet of which 0 is ready.this means 1 deployment failed. letse see 
        status of pods-

            kubectl get pods.

        here we see that 0 of 1 pods are ready. and we can also see the error- ImagePull error. reason for this is cluster is in 
        virtual machine and image exist in local machine. so we need to pull image form docker hub. 
        
        so lets delete this dpeloyment -

            kubectl delete deployment first-app

        In course we pushed image on docker hub and fetched the resources form there, but on office lapop it was not wrking. still
        i was getting error in puling image. so i used this approach -
            https://minikube.sigs.k8s.io/docs/handbook/pushing/
             i used this way -

                minikube cache add kub-first-app

        now run -

            kubectl create deployment first-app --image=kub-first-app

    4) see the staus of deployments and pods -
        kubectl get deployments
        kubectrl get pods
        
188)kubectl:behind the scenes

    see slide 7.
    Now on that Worker Node,we got this kubelet service,which I also mentioned in the last course section,
    which now manages the Pod here,starts the Container in the Pod and basically also monitors this Pod and checks its health.

189)Service Object
    To reach a pod and the container running in a pod,we need a service.Because a service object is another object Kubernetes knows,
    which is responsible for exposing pods to other pods in the cluster, or very important to us here to visitors outside of the
    cluster.So to the entire world.

    Now service, groups pods together and gives them a shared address a shared IP address.And this address then won't change.
    So you can use a service to move multiple pods into that service and make them reachable on that service unchangeable IP 
    address.And even better than that,you can also tell the service to expose this address which doesn't change not just inside
    of the cluster,which you also can do,but also outside of the cluster.

    The default is that it's internal only but with a service, we can overwrite this.So without services, pods are very hard to reach

190)Exposing a deployment with a Service
    we created the service using -

        kubectl expose deployment first-app --type=LoadBalancer --port=8080

        to see diffrent types of services, see commands section.

    then checked whether it is running or not by -

        kubectl get services

    name of service is same as deployment i.e first-app

    here we saw our service but external-ip is still pending.Now, if this would be deployed on a cloud provider,we would actually see an
    external IP here,but for minikube,this will always stay in the pending status.but minikube has a command,which will give us access to
    the service by basically mapping a special port to an IP which we can reach from our local machine,and which identifies this virtual
    machine running on our local machine.

        minikube service "nameOfService" => minikube service first-app

    this  shows the service name and ip that will be opened automatically in browser, here you can see your running application.
191)restarting the continers
    Here we saw that containers are restarted automatically when some error occurs in our code.This the behaviour we get when we crate a 
    deployment. we can see how many times a pod has 
    restarted by this command -

        kubectrl geet pods 


192)Scaling in Action
    here we ran this command - 
        kubectl scale deployment/first-app --replicas=3

    it will create new replicas or instances of pod.since we have load balancer.at last we again chnaged replicas to 1

193)Updating the deployment
    1)chnage code.
    2)generate new image.
    3)upload image on docker-hub.
    4)run this command -

        kubectl set image deployment/"name of deployment" containerName="image name"

        kubectl set image deployment/first-app kub-first-app=kub-first-app

        we get the name of container via UI,


        This replaces the image in container of give deployment with new image.it sets the image for already running deployment.

        now by default you will not see any chnage this is because existing image is downloaded only if tag is chnaged, there are ways
        of changing this but its gud to chnage tag name on image update, so we update the image tag -
    5)update image tag -

        docker build -t  kub-first-app:2 .

    6)uopload the image on docker hub
    7)run kubectl command -

        kubectl set image deployment/first-app kub-first-app=kub-first-app:2


        now kubernetes detects the chnage in image tagm so it redownloads the images and retsarts your container based on this.
        we get image updated confirmation.

    8)you can check the updating satus by -

        kubectl rollout status deployment/"name of deployment" => kubectl rollout status deployment/first-app


    In kubernetes dashboard go to  -> pods(on left pane) -> click on pod name.

    here under events you can see that new image was downloaded and new continer was created based on that image.

    at the bottom you can see contianer name and image name on which that container is based off of.


194)Deployment Rollbacks & History

    here we tried to use a image that does not exist - 

        kubectl set image deployment/first-app kub-first-app=kub-first-app:3

    There was no error. lets check the progress of our rollout -

        kubectl rollout status deployment/"nameOfDeployment"
        kubectl rollout status deployment/first-app

    here we can see that deployment is in progress and old replica is shutting down.In dashboard also under pods you can see that
    1 pod failed to pull images and another is ruuning. so old pod was not shut down because newer does not started running.this is
    rolling update strategy. so lets rollback this deployment because this has failed anyway.

        kubectl rollout undo deployment/"deoploymentName"
        kubectl rollout undo deployment/first-app

    now no of pods is one and in rollback status also we saw success message.

    now how can we go back to previous rollout-

        1)get all rollout details - 
            kubectl rollout undo deployment/first-app --to-revision=1

        2)to see which image was used in a rollout -
            kubectl rollout history deployment/first-app --revision="identifier"
            kubectl rollout history deployment/first-app --revision=2

        3)to back to a reviion -

            kubectl rollout deployment/first-app --to-revision=1

195)imperative vs declarative approach
    impretaive approach means using config file instead of commands to manage kubernetes.
