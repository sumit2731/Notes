{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Calibri;}{\f2\fnil\fcharset0 Open Sans;}}
{\colortbl ;\red255\green255\blue0;\red255\green0\blue0;\red204\green255\blue217;}
{\*\generator Riched20 10.0.14393}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs40\lang9 2)How to edit and run code in chrome\par
\fs24 go to source in chrome dev tolls. there are various ways we can write code in chrome dev tools. go to snippets. then have new snippet, name it main.jss. so we will write our js code in this file. how we execute it. press play button on right hand side.\par
\fs40 3)what is "use strict" and what does it do\par
\fs24 it allows you to place a function or program in whats called strict operating context. we will see what it is. it makes debugging easier. code errors which otherwise would have been ignored or would have failed silently will now generate errors and exceptions.this alerts you about errors in your code and directs you quickly  to probable source. so how do we turn it on-\par
"use strict";\par
write this on top of your js file. why string , this is because when it was launched all browsers dnt supported it. if use strict was keyword then they would have given error. so we came up with "use strict".\par
there is another method which is used in legacy codes-\par
\highlight1 // Not strict mode..\par
function newCode()\{\par
"use strict";\par
//strict mode\par
\}\par
\highlight0 here we are writing some code in strict mode and some in non strict code.\par
why use strict mode?\par
1)using a variable before it is defined , causes error.\par
code-\par
\highlight1 sumit ="sood";\par
console.log(widow.sumit);\par
\highlight0 if we dnt use strict mode then first statement would create a property named sumit on global object(in browser it is called window) and code will work fine.\par
what  is problem with it? code-\par
\highlight1 var theVal =0;\par
theVl =1;\par
if(theVal >0)\{\par
\}\par
\highlight0 if we dnt use this mode then it will be very hard to debugg this code.but if we use strict mode then it will give us error that theVl is noot declared. so it makes easier to debug our code.it tells us upfront that this is syntax error in my application, so we dnt have to spend hours on debugging it.\par
\par
2) it stops us from using keywors that are reserved for future versions of java script\par
ex-\par
var let =1;\par
let is used in ES6.\par
3)you cannot delete functions,varibale or function arguments in strict mode.\par
ex-\par
\highlight1 var foo = 1;\par
delete foo;\par
function moo()\{\};\par
delete moo;\par
\highlight0\par
4) it makes makes evel safe to use.\par
in non-strict mode-\par
var eval = 1;\par
this is fine but in strict mode it will error.\par
strict mode also makes act of calling eval a bit safer. eval lets you evaluate a js expresion by passing string. it lets you evaluate arbitary bits of javaScript code.\par
in non-strict mode, a is declared as global varibale and this works fine-\par
eval("var a =1"); \par
console.log(a);\par
in strict mode-\par
\highlight1 "use strict"\par
var a =2;\par
eval("var a =1");\par
console.log(a);\par
\highlight0  a= 2 is printed.\par
in strict mode the variables that we declare inside eval code remains inside eval mode and dnt leak out. if we dnt decalre a outside eval then it will, say a is not declared.\par
eval is powerful feature of js, so you should treat it with respect.\par
\par
\fs40 4)does java script pass varibales by refrence or by value\highlight1\fs24\par
\highlight0 it means how variable are passed to functions. Answer is-\par
Primitive data types are passed by value and objects are passed by refrence.\line objects are passed by refrence to function. we can only add or change properties on this object . we cnt make it point to new object. ex-\par
This is fine\par
\highlight1 var sumit = \{\};\par
function f1(obj)\par
\{\par
obj.sood ="surname";\par
\} \par
f1(sumit);\par
\par
\highlight0 This not fine-\par
\highlight1 var sumit = \{\};\par
function f1(obj)\{\par
obj =\{ prop1: "js"\}\par
\}\par
f1(sumit);\par
\highlight0 this change wnt reflect outside the function. so we can change a property of object or we can add a property. we cnt change to what that object points to.\highlight1\par
\par
\} \par
\par
\highlight0\fs40 5)what are difrent types in js\par
\fs24 primitive types- number,string, boolean,undefined,null\par
non-primitive type - object.\par
note - if we use typeof operator on null, it returns object. this is incorrect.it is bug in java.\par
\fs36 d/w between a dynamically typed language like js and statically typed language like Java\par
\fs24 it means in js type of varibale is determined at run time. same variable can be number,string, boolena at duffrent time. it depends upon type of value that we assign to this variable.\par
\fs32 Null vs Undefined\par
\fs24 null means variable dnt has any value. Undefined means it may have value but we dnt know it yet.\par
Undefined is used-\par
1)when we decalre a variable its type is undefined.\par
var a;\par
console.log(a);\par
2)if we dnt pass parameter in function calling, then value of that paraemeter is null.\par
function f1(a)\{\par
console.log(a);\par
\}\par
f1();\par
\par
3) when we try to acess a property on object that is not defined. we get null.\par
\par
other important diffrence is that, only programmer sets a variable equal to null, js cnt do that.  js engine can set a variable to undefined.\par
null == undefined\par
it gives true.\par
\fs40 7)what is NaN and how can we check for it?\par
\fs24 it stands for not a number. it happens when we do some calculation on something that is not a number-\par
abc/4\par
its type is number.\par
some properties of nan-\par
1) NaN compared with anything is false. even if we compare it with itself it well then also returns false(NaN === NaN). so we have special function in js, that checks it.-\par
isNaN(1)- returns true or false. but this function has its own problems-\par
Nan("A") - returns true. it is beacuse js converts string A into numbers. so its becomes NaN. so what ever value we give to isNaN function, it will try to convert it into number and then check it.\par
isNaN("1") - false. This is because "1" is converted into 1. if want to see how a value is convert into number-\par
Number("1")\par
similarly for string-\par
String(1).\par
so what is way to makr sure that value is Nan.\par
\highlight1 var a =NaN;\par
a !== a\par
\highlight0 if it returns true, it means it is NaN. because NaN is only value that is not equal to itself.\par
this is very important concept.\par
\fs40 10)What is scope chain\par
\fs24 we have 2 types of scopes- global and functional. lets say we have a ineer function inside our function. then if we try to read some variable then it looks into scope chain.first it will search for that variable in inner function, if it cnt find it in there  it will go to outer function. if it is not found even there then it will  continue to go outer,outer and outer until it reaches  global scope. then it is callled scope chain.this is how js resolves a variable.\par
Scope chain is defined by the way the program is written in the file.\par
\highlight1 functon foo()\{\par
console.log(myvar);\par
\}\par
function goo()\{\par
var myvar =1;\par
foo();\par
\}\par
goo();\par
\highlight0 here we get the error that myvar is not defined. reason for this is scope chain is defined lexically.it means scope chain is defined in the order in which code is written on file.so myvar is not avalible to foo bcoz myvar is defined above foo function.\par
variable are resolved in order on which code is written on page.however if we define foo inside goo then it will print myvar. it first looks for this varibale in scope of foo, it dnt find it, then it moves to scope of goo, there it finds it.\highlight1\fs40\par
\fs24\par

\pard\sa160\sl259\slmult0\highlight0\fs40 12)What are function closures\par
\fs24 According to scope rules when a functions exits , any variable declared in that function go out of scope and are deleted.one exception for that is with closures.\par
When ever function returns a functions, a functions that is returned keeps a refrence to any variables that it needs to execute.like in our example it keeps the refrence to text variable. We can see these closure in chrome dev tools. In scope we have local, global and closure field. So inner functions first looks inside its local scope for text variable, it wnt find it. then it looks for text variable in closure, here it finds it. If it dnt find it in closure then it will look for it in global scope.\par
This is what closure is. It is special set of refrences to variables that a function needs in order to execute , variable that are out of this function scope.\par
\highlight1 "use strict";\par
function sayHello(name)\par
\{\par
    var text = 'Hello' + name;\par
    return function()\{\par
        console.log(text);\par
    \}\par
\};\par
\par
var sayAsim = sayHello("Asim");\par
sayAsim();\par
\highlight0 output -\par
Hello Asim\par
closure can be very complex, but there are couple of things that you need to know about them-\par
1)they can refer to variables in outer scope, in scopes external to itself(scope of function). In our example, since a function is returned by sayHello ,it is going to be closure. So it can refer to variable in scopes outside of itself in outer scope. Like its referring to text variable, which is in outer scope in scope of function sayHello.\par
2) it can refer to those variable, variable in outer functions even after those outer functions have returned.\par
But that\rquote s the basic knowledge. Interview will ask something like this-\par
\highlight1 var foo = [];\par
for(var i =0; i < 10; i++)\{\par
    foo[i] = function()\{\par
        return i;\par
    \};\par
\}\par
console.log(foo[0]());\par
console.log(foo[1]());\par
console.log(foo[2]());\highlight0\par
\par
output-\par
10\par
10\par
10\par
here in order to work, our function requires variable i, which is global scope(outer scope). So its again creating a closure. For this function to work, it requires i variable(which is in outer scope). \par
Output is it because when closure are created they did\rquote nt get the copy of variable they get a refrence of it. Here i points to actual value of i in outer scope. So by the time we call function, all loops have been exhausted and value of I is 10. So 10 is printed in each call.\par
So closure points to current value of whatever variable are used in function body.\par
So what to do if want different value of I in each function, here we use concept of IIFE \f1\endash\f0\par
\highlight1 var foo = [];\par
for(var i =0; i < 10; i++)\{\par
(function()\{\par
var y=i;\par
foo[i] = function () \{return y \} ;\par
\})();\par
\}\par
console.log(foo[0]());\par
console.log(foo[1]());\par
console.log(foo[2]());\highlight0\par
Here we define a variable in function and return  that variable. Now each function has its own scope. So when  we call function , we create variable y and assign it whatever value of i was when that function was executed. And then we return y instaed of i in our closure. What happened here-\par
When we define a function f[i], we know we need to have y in order to execute that function. So it stored the refrence to y variable, internally in its own closure. So even when our IIFE function exited, y variable is not destroyed(because closure has refrence to it). So when we are calling function(foo[i]()), it is getting value of y when that iife was created. that;s neat trick with IIFE that get you round this problem of closures and fact that closures only point to current value of outer scope variables rather than the value of the time when closure was created.\par
So concept is-\par
Closure point to current value of outer scope variables rather than the value at the time when closure was created. What we are doing  here is we creating a scope, a scope just for this  closure, then you basically are snapshoting whatever values you need for that closure at that moment in time.\par

\pard\sa200\sl276\slmult1\par
but there is also a cleaner way of solving this problem-\par
\par

\pard\sa160\sl259\slmult0\highlight1 var foo = [];\par
for(var i =0; i < 10; i++)\{\par
(function(y)\{\par
foo[y] = function () \{\par
return y \par
\} ;\par
\})(i);\par
\}\par
console.log(foo[0]());\par
console.log(foo[1]());\par
console.log(foo[2]());\par
\par
\highlight0 so we covered 3 tiopics in closures-\par
1)what is closure and closure can refer to outer scope variables and functons even if outer scope variable are exited\par
2)it refers to current value of outer scope variables. not value of outer scope variable when that scope was created\par
3) then we saw that we can achieve the behaviour with IIFE\par
\par
\fs40 14)What does this keyword mean\par
\fs24 see js notes on copy tutorial 7,unit 2\fs40\par
\fs24 if we use this outside of any function then this points to global object which is window in case of browser.\par
In function what "this" means , depends on way function is called(calling context).\par
\highlight1 var asim =\{\par
checkThis: function() \{\par
console.log(this);\par
\}\par
\};\par
asim.checkThis(); // way 1\par
var func = asim.checkThis;\par
func(); // way2\par
\highlight0 In way 1, this points to object asim. in way 2 this points to global object.\par
lets see some complicated example-\par
\highlight1 var asim = \{\par
checkThis: function()\{\par
console.log(this);\par
function checkOther()\{\par
console.log(this);\par
\}\par
checkOther();\par
\}\par
\};\par
asim.checkThis();\par
\highlight0 now first this points to asim object, second this points to window object. this is because\par
in second case function is called normally(see js copy notes).\par
now using this can cause confusion some times-\highlight1\par
var asim = \{\par
checkThis: function()\{\par
console.log(this);\par
function checkOther()\{\par
this.moo =1;// \highlight2 here this points to global object becoz of the way it is called down th line\highlight1\par
console.log(this);\par
\}\par
checkOther();\par
console.log(this.moo); \highlight2 // here this points to asim because of the way function is called, so undefined is printed  but we expecte it to print 1\par
\highlight1\}\par
\};\par
asim.checkThis();\par

\pard\sa200\sl276\slmult1\highlight0  here we expected we will print 1 but thats not the case because this points to diffrent things in outer and inner functions. so how do we stop this confusion?\par
answer is "use strict;" in strict mode, this cnt point to global object . it will give us an error.it prevents us from potentially making a mistake. how do we solve the above problem. we will see no of soolutions in coming lectures . but common solution is to stabalize the this keyword, into other keyword at the top of your function.\par
\par

\pard\sa160\sl259\slmult0\highlight1 var asim = \{\par
checkThis: function()\{\par
\highlight2 var self = this;\highlight1\par
console.log(\highlight2 self\highlight1 );\par
function checkOther()\{\par
console.log(\highlight2 self\highlight1 );\par
\highlight2 self\highlight1 .moo =1;\par
\}\par
checkOther();\par
console.log(\highlight2 self\highlight1 .moo); \par
console.log(window.moo); \highlight2\par
\highlight1\}\par
\};\par
asim.checkThis();\par
\par
\par

\pard\sa200\sl276\slmult1\highlight0\par
now instead of refering to this we refer to self. at the top this refered to asim object. now self refers to asim object. all over the code we use asim. some people vm,that. but purpose is same.\par
\fs40 15)what does call,bind and apply do\par
\fs24 value of this is very unstable. it is'nt determined by how code is written on page.it's not lexical. it is infact determined by how a function is executed.so we need some ways to stabalize this value so that we can be confident in what its value will be as we are coding. we saw the way in last lecture.\par
all these functionm are just diffrent ways in javascript of locking down and stabalize the this keyword.\par
in js functions are objects with some properties and some of these properties(name,length,arguments) are agian functions. we can even add our own properties to these functions.\par

\pard\sa160\sl259\slmult0\fs36 1)call-\par
\fs22 asim.call()\par
asim is function. We can call it using .call. to call we can pass a parameter. Now this in function will refer to parameter that we pass to call function. We can pass empty object, then this will point to empty object. Solution to problem in last lecture-\par
\highlight1\ldblquote use strict\rdblquote ;\par
Var asim =\{\par
checkThis: function()\{\par
function checkOther()\{\par
console.log(this);\par
\};\par
checkOther.call(asim); \highlight0 // now this is checkOther will point to asim\par
\highlight1\}\par
\};\par
Asim.checkThis();\highlight0\par
So we use call to stabilize this function.\par
Asim() => Asim.call();\par
It means both are equivalent. If we are not using strict mode then in both cases this will point to window object. If we use strict mode then this will point to nothing.\par
\par
What if our function takes parameters? Then to call first argument is what this should point to, the we pass function arguments. Ex-\par
Asim(\{\},2,34,); // here first argument is what should this point to, followed by parameters of Asim function.\par
\fs36  2)apply-\par
\fs24 asim.apply(1,[2,3,4,])\par
it is similar to call, first parameter is what this should point to, then arguments to function are passed in array.\par
So whne do use apply and when use call. We use apply when we pass many arguments to function, instead of passing these paramneters one by one one we can pass the array. Array we pass to apply will be caught by arguments array in apply.\par
Ex-\par
\highlight1 function sum()\{\par
var total =0;\par
for (var i=0; i < arguments.length; i++)\{\par
total += arguments[i];\par
\}\par
return total;\par
\}\par
var things = [1,2,3,4,53,4,56,1];\par
var x = sum.apply(null,things);\par
console.log(x);\highlight0\par
\fs36 3)Bind\par
\fs24 By using bind we can define what this will point to. We can do his when we define our function, that\rquote s the difference.\par
Ex-\par
\highlight1 var a= function()\{\par
console.log(this);\par
\}.bind(1);\par
a();\highlight0  // this wll point to 1, because we set it in this way\par
even if we do this-\par
\highlight1 var asim =\{\par
func: a\par
\};\par
asim.func(); // even now this will point to 1, because we set in function declaration\highlight0\par
now we call function normally and our this will point to what we passed in bind at time of declaration.\par
One important thing to note is-\par
\highlight1 function a()\{\par
console.log(this);\par
\}.bind(1);\highlight0\par
\highlight3\f2\fs23 bind can only be used on functions after they have been created and assigned to a variable\highlight0\f0\fs24\par
This wnt work. We need to use function expressions if we want to use bind. Reason for this is bind can be tied to object only , and by using function expressions we are creating objects.\par
\par
\fs40 16)What is Prototype Chain(Object.create)\par
\fs24 See copy notes of angular to\par
\par
animal.isPrototypeOf(asim), this will return true if,\par
asim.__proto__ = animal;\par
as we know that __proto__ property is not supported by many browsers(ES 6 supports it), so how to we setup prototype chan. \f1\endash\f0\par
var asim = Object.create(animal);\par
here animal is aobject with proteries.it means animal is prototype of asim. i. e it is equivalent to-\par
asim.__proto__ = animal.\par
So it means by using create method we can set up prototypes of objects. Now we can also add properties to asim  using Object.create.\par
var asim = Object.create(animal,\{food:\{value: \lquote mango\rquote\}\});\par
this will add property food to asim and value of this property will be mango.\par
\par
\fs40 17)Difference between prototypal and Classical Inheritance\fs24\par
Classical Inheritance-  it is how inheritance works in c++/java. We have a class, then we create objects from it.i.e instances of classes\par
Prototypal Inheritance \f1\endash\f0  it is how inheritance works in js. We create object from obects.\par
In js we have a methodby which we can emulate classical inheritance . atleast it looks like it in code.its some times called classical inheritance,some times construct pattern, sometimes Pseudo-Classical Pattern. Note that there is\rquote nt real classical object oriented method in java script because all object orientation in js is based on prototypes. \par
So we have 2 methods to implement inheritance_\par
 Fake Classical pattern(Pseudo Classical pattern)\par
Direct Prototypal Pattern\par
So classical pattern is faked in js.see figure in video in last.\par
\fs40\par
18)What is constructor OO Pattern?(part 1)\par
\fs32 Here we will create psedo class i.e will call Functions in constructor mode\par
\fs24 Here we will see how to implement pseudo classical inheritance in js. We will see how to implement psedo classical OO principle in js.object oriented concepts and inheritance in js are really hard to learn.bcoz there are no core language features to support it. Some of these are in ES6(like class). But we can mimic object oriented concepts(that are used in c++,java) in js by using function constructor and new keyword.this way is called classical inheritance,psedo calssical inheritance and constructor pattern. Here is how w emimic class in js-\par
\highlight1 function Person(first_name,last_name)\{\par
this.first_name = first_name;\par
this.last_name = last_name;\par
\};\par
var dude= new person("asim","hussain");\par
\highlight0 Here we saw how we can create object by calling functions in constructor mode. Then we saw that there are 2 ways to add methods to these objects created. First is to define the property in function as we do with other property. Like-\par
\highlight1 Function Employee()\{\par
this.salary = 70,000;\par
this.getSalary = function()\{\par
return this.salary;\par
\};\par
\}\highlight0\par
Second method is to add methods to the prototype of Employee Function.\par
\highlight1 Employee.prototype.getSalary = function()\{\par
return this.salary\par
\};\highlight0\par
Advantage of second approach is that we are saving memory. All instances of object created , share this property.in fisrt approach we add functions to each instance. In most cases we should use second approach.\par
But we have advantage in first approach. Which is here we can similate a private member variable.by this approach once we have set the value by constructor we cnt chnage it. To implement private variavles to this-\par
\highlight1 Employee(salary)\{\par
this.getSalary = function()\{\par
return salary;\par
\};\par
\}\highlight0\par
\highlight1 var emp 1= new Employee(8000);\par
emp1.getSalary();\highlight0\par
this behavior is possible only because of Closure in js. As we return this in Employee function, salary variable is accesible because of closures. Now we cnt access salary because it is in function scope. But it can be accessed via getSalary function because of closures.\par
\highlight2 So here we implemented psedo classes and pseudo private variables in those classes.\highlight0\par
\fs40 19)What is constructor OO Pattern?(Part 2)\par
\fs24 In last lecture we saw that how we can have have psedo classes by calling functions in constructor mode.here we will see how do we implement inheritance in psedo classical patern or constructor pattern.\par
Ex-\par
\highlight1 function Person(first_name,last_name)\{\par
this.first_name = fisrt_name;\par
this.last_name = last_name;\par
\};\par
\par
Person.prototype.full_name = function()\{\par
return this.first_name + \lquote  \lquote  + this.last_name;\par
\};\par
function  Professional(honorific,first_name,last_name)\{\par
Person.call(this,first_name,last_name);\par
this.honorific = hororific;\par
\};\par
\highlight2 Professional.prtotype = Object.create(Person.prototype); // we have inheritance because of this line.\par
\highlight1 Professional.prototype.professional_name = function()\{\par
return this.honorific + \lquote  \rquote  + this.first_name+ \lquote  \rquote + this.last_name;\par
\}\highlight0\par
\highlight1 var prof = new Professional(\ldblquote Dr\rdblquote ,\rdblquote Asim\rdblquote ,\rdblquote khan\rdblquote );\par
console.log(prof.professional_name());\par
console.log(prof.full_name());\highlight0\par
Here person is our Parent  class and  Professionalmis our child class. We can implement inheritance if prototype of professional functions points to prototype of person function.we can do it via this-\par
Professional.prtotype = Object.create(Person.prototype);\par
What this has done, see figure in video (09:24). 2 figures in video.\par
All object orinted principles in java script are based on prototype chain.\par
Here what we are doing is- first we rereated prototype of Professional. Then we made __proto__  of Professional's prtotype  point to  Person\rquote s prototype.then we added some function's on professional's prototype. note that here order is important first recreate protype of professional then add functions to it.   When we call any function on prof, first it will look on itself, then it will look on its protype, then it will look on prototype of its protype. so here we have a prototype chain.\par
\par
\fs40 20)What is ProtoType OO Pattern?\par
\fs24 In last lecture we saw OO  pseudo inheritance(classical inheritance). Here we will saw this type. It is lot easier. It is just prototype chain. Here we dnt create psedo calls(function in constructor mode). We basically say, create a object whose prototype is this other object and also please built this object with some new properties. Advantage of this approach is , here we are working with tools that java script supports natively rather than attempting to imitate features of other language. Ex-\par
\highlight1 var Person =\{\par
full_name: function()\{\par
return this.first_name + \ldblquote  \rdblquote  + this.last_name;\par
\}\par
\};\highlight0\par
\highlight1 var asim = Object.create(Person);\highlight0\par
Person is our base object , we then built another object whose prototype points to this base person object. Now __proto__  property of asim points to Person. So now asim can access properties on Person object. We can call full_name function on asim. Now problem is that we dnt have peopreties on our asim object. In last approach we added them to this keyword..\par
Here we will see couple of approaches-\par
1)first approach is , we use a function in base object to do so.\par
\highlight1 var Person =\{\par
init: function(first_name, last_name)\{\par
this.first_name = first_name;\par
this.last_name = last_name;\par
return this;\par
\},\par
full_name: function()\{\par
return this.first_name + \ldblquote  \rdblquote  + this.last_name;\par
\}\par
\};\highlight0\par
\highlight1 var asim = Object.create(Person);\highlight0\par
\highlight1 asim.init(\ldblquote asim\rdblquote ,\rdblquote hussain\rdblquote );\par
conslole.log(asim.full_name);\highlight0\par
2) SECOND Methodis to use second argument to create function. Second parameter is object which describes the peorperies that we want on asim object.first_name property expects a object. Now inthis object we can define not only value we can also define some other things, like whether it is read or write, is it enurmable etc.\par
\highlight1 var Person =\{\par
full_name: function()\{\par
return this.first_name + \ldblquote  \rdblquote  + this.last_name;\par
\}\par
\};\highlight0\par
\highlight1 var asim =  Object.create(Person,\{\par
first_name: \{value: \lquote Asim\rquote\},\par
last_name: \{value: \lquote Hussain\rquote\}\par
\});\par
console.log(asim.full_name);\highlight0\par
second approach is very verbose. So third solution is preffred.\par
3) here we create a another function named PersonFactory. Factory is a function that just returns a Object.\par
\highlight1 var Person =\{\par
full_name: function()\{\par
return this.first_name + \ldblquote  \rdblquote  + this.last_name;\par
\}\par
\};\highlight0\par
\highlight1 function PersonFactory(first_name, last_name)\{\par
var person =  Object.create(Person);\par
person.first_name = first_name;\par
person.last_name = last_name;\par
return person\par
\}\par
\par
var asim = PersonFactory(\ldblquote asim\rdblquote ,\rdblquote hussain\rdblquote );\par
console.log(asim.full_name);\highlight0\par
\par
we saw 3 approaches, it is personal choice which one we want to use. So we covered how to create instances of objects which point to other objects via that prototype approach.\par
the question is how to do we inherit? With prototype method , there is\rquote nt any specific inheritance methodology. We just keep on adding to prototype chain. Lets say we want a Professional class and we want it to inherit from Person as we did in last lecture.\par
\par
\highlight1 var Person =\{\par
full_name: function()\{\par
return this.first_name + \ldblquote  \rdblquote  + this.last_name;\par
\}\par
\};\highlight0\par
\highlight1 var Professional = Object.create(Person, ,\{\par
professional_name: \{value: function()\{\par
return this.honoric + \ldblquote  \rdblquote  +this.first_name+ \ldblquote  \rdblquote + this.last_name;\par
\}\par
\}\par
\});\par
var asim = Object.create(Profesional);\highlight0\par
\highlight1 console.log(asim.full_name());\par
console.log(asim.professional_name());\highlight0\par
\par
now all we have to do here is to add properties to professional object or asim object. We can do that by approaches already covered. One way is to add a init function to professional. We can also create a professionalFactory function.\par
So this is prototypr pattern.\par
You might be asked in interview when will you use pseudo classical or constructor pattern , and when you will use prototype pattern? Both are common. Both are widely used. They have advantages and disadvantages-\par
Pro of constructor pattern-\par
1)By far it is most common.its written everywhere. So you should know it. So that you can recognize code written in this pattern.\par
2)we can private variables, ptotypes approach does\rquote nt support this feature.\par
3) this is similar to languages like, java,c++ etc.\par
\par
Pro\rquote s of prototype pattern-\par
1)Very easy to understand\par
\par
You can use any one of 2 the but it is necessary to know about both of them.\par
\par
\par
\par
\par
\par
\par
\par
here asim points to professional, professional points to person. So that\rquote s it that\rquote s how you do inheritance in prototype pattern.\par

\pard\sa200\sl276\slmult1\highlight1\par
}
 