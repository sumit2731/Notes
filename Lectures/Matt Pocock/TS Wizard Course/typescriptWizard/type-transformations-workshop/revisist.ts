/**
 * Lecture 6 - Extract helps to pick types from Union without giving full type.
 * also see how extends works
 */

/**
 * Lecture 14 - here we saw that we can use string in template literals to represents any string -
 *
 * ${string}
 */

/**
 * 17- 19  - I solved all but also see alternate solutions
 *
 * alternate solution used Record. See definition of Record to see how we can put constraint of something to be
 *  of union type
 *
 *20 - go through notes. undesrtand idea about type functions
 * 20.6 - {} can be used to in generic condition to accept any value other than null or undefied.
 *
 * Object or {} - represents all values except null or undefined
 * object - represents all non-primitive values
 *
 * This also tells us how Typescript matches object i.r extra properties are allowed. this also explains a bit
 *  how extends works in case of object
 */

 /**
  * 21 - now we will have if else logic in our type functions. read comments in solution
  * 
  * 23 - infer can be used in conditional types
  * 
  * 24 - a bit different use of infer to extract argumnets from generics
  * 
  * 25 - using infer on template literals and using template literals as capturing groups
  * 
  * 26 - powerful paradigm of extracting something out from functions without having to declare types
  *   on them
  * 
  * 27 - new way of using infer. which helps us to avoid nested ternaries
  */

/**
 * See how you defined utility types -
 * 
 * Awaited
 * ReturnType
 * ParameterType
 * 
 */
