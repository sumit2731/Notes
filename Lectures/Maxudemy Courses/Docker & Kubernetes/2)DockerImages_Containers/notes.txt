Part 1(build images, run containers) -


    Images contain the code, the setup, the meet, you could say and containers are then the running instances of those images.
    1)first we created a docker based on node image on docker hub abd accessed terminal inside container from our hosting 
        machine.
    2)then we build up on that image and created our custom image.we executed our node js code with node image from docker hub.
        Typically you would pull into your official base image and then add your code on top of that to execute your code with 
        that image.

    3)to create our own docker image, instruction are specified in Dockerfile. so we create Dockerfile.

    4)then we create(or build) a image based on instructions specified in DockerFile.run this -

        build .
            here . means Dockerfile is at same path where we are running this file.

        this returns a docker image id.

    5)then we use that id to run a container.

        docker run "imageId"

    6)then we saw how we can connect contsiner port to port on local system by using p flag with diocker run.
        docker run -p 3000:80 dockerImage

        commit - Docker Commit1

    7)then we saw layerbased architecture of docker. how chnaging one layer means that subsequent layers(commands) should
    run again.It exists to speed up the creation of images since Docker only rebuilds and re-executes what needs to be
    re-executed.here we also improved the performance by copying the package.json first. see code2, for chnged Dockerfile,
    here we chnaged the sequence commands for better performance.


    commands -

        1)docker run "imageId"
            creates a contianer form image and runs that container in attached mode by default. imageid can exist on system or
                on dockerHub.

            Examples - 

                docker run node
                    It downloads the node docker image from docker hub(if not found locally) and creates the contianer based 
                    on that image.here container is created and exited automatically because intercative shell created in 
                    container is not exposed to us automatically.for that we can add flag -it, we will actually tell Docker 
                    that we wanna expose an interactive session from inside the container to our hosting machine.

                    docker run -it node

                    flags -

                        1)-p = for attaching port.
                            docker run -p "loalPort":"imagePort" dockerImage
                            it runs the dockerImage into contianer and connect port 3000 of local system with port 80 of docker 
                            container.
                        
                        2)-d = dettached
                            docker run -d "imageId"
                                for running container in detached mode. it returns the id of detacched container. which can be later 
                                used to attach the container.

                            using multiple flags -

                                docker run -p 8000:80 -d "imageid"

                        3)-i  interactive
                            docker run -i "imageId"
                                runs docker container form image, and give intercative terminal.generally used along with "t" flag.
                                but i am not able to find any difference by attsching "t" flag.
                                docker run -it "imageId"


                        4)--rm
                            it automatically removes the container when it exists.
                            docker run -p 3000:80 -d --rm "imageId"
                            


Part 2(Managing Images & Containers)(see slide 9 ) - 

    container can be in 2 modes-
        attached - attached simply means that we're listening to the output of that container.For example, to what's being printed to 
         the console.
        detacched - we are not listening to outputs.


    commnads -
        1)docker start "containerName"(or contianerId)
            this restarts a container in detached mode.

            flags -
                1)a - attaches the started container.
                    docker start -a "containerName". this is for listening the output, i.e this is listen only mode.if you
                    want to give input, use -i flag.

                2)i - interactive flag.you give input also.
                    docker start -a -i "containerName". you can use -t flag but if orignally container was started with -t flag
                    then that will be memomized.

        2)docker container attach "containerId"
            Attcahes a detacched container.

        3)docker attach "containerName"
            attaches a running container

        3)docker logs "containerName"
            fetches the past logs for containers.

            flags -

                -f - follow. keeps on listening and prints future logs also. we are simply attaching docker gain.

Part 3 (python, code 3) -

    here we ran a python program which waits for 2 inputs form users.there we saw if we need to give inputs to program running
    inside container, we can use -i flag with docker run and docker start.


    The running container is then actually not really that big,it's just an extra thin layer, the command layer basically, added on top of the image.
    So, this image code is used in the running container.it's not copied again, just to make this clear.multiple container share same image code.

    That's why this code inside of the image is also locked in and read only containers can only make changes,And for example, create files inside of
    that new extra thin container layer that was added on top of all the image layers.

    then we saw cp command which allows us copy to and copy from container. it can be useful to copy config file into container
     and copy log file out from contianer.


    In slide 11, we can see  2 options of sharing image with others.then we uploaded a image on docker hub so that anyone can download it.

    then we saw how we can name docker container while running them. then we see saw naming system iof images -
         name: tag


         note that tag is optional.

         see slide 10.


    then we pushed a image into dockerHUb and then downlaoded that image from docker hub.




    commands -

        1)docker rm "container1Name" "container2Name" "container3Name"
            It removes the contianer. this container should be stopped first, you cannot remove a running container.

        2)docker container prune
            removes all stopped containers at once.

        3)docker images
            lists all images

        4)docker rmi "image1Id" "image2Id" "image3Id"
            it removes the image and all its layers. you can only remove the images which are not used by any containers.
            that means even if image is used by container and that container is stopped, first you need to delete the 
            contianer, only then you can remove the image.

        5)docker image prune
            removes all images which are not used by any containers.

        6)docker image inspect "imageId"
            gives the details about a image.

        7)docker cp - docker cp "path1" "path2". copies files form path1 to path2.
            docker path is specified by dockerName:pathInsideDocker
                ex - a)docker cp dummy/. strange_neumann:/test (copies file from local to conatiner. dummy/. means copy all contents 
                    inside dummy, we can also target induival files)

                    b)docker cp strange:/test dummy (copies file from container to local system)

