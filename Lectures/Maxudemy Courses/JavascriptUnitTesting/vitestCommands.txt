matchers -
    
    1)expect(a).toBe(0)
        

    2)expect([1,2,3]).toEqual([1,2,3])
        
        toBe compares by value, cannot be used to compare refrence types.
        for comparing refrence types use - expect([1,2,3]).toEqual([1,2,3])

        It won't perform a deep equality check.

        Check section 6 lecture 48 for difference

    3)expect(a).toBeDefined()
        .toBeUndefined
        .not.toBeDefined()

    4)testng error - see math.test.js in section 3. on how to assert whether function throws or not.
        const resultFn = () => {
            add();
        };
        a)expect(resultFn).toThrow(); // just checks for error to be thrown
        b)expect(resultFn).toThrow('some strng'); // also checks for error thrown and a prticular message, can be string or regular exp or Class Cnstructor

    5)not -
        expect(a).not.toBe(0)
        expect(resultFn).not.toThrow(); //https://jestjs.io/docs/expect#tothrowerror

    6)toBeTypeOf

        expect(result).toBeTypeOf()

    7)toBeNaN()
        expect(result).toBeNan()


    8)toContain('someString')
        expect(someSTr).toContain('sunStr)

        This checks if -
            a)string conatins a subtring
            b)if array contains a item

        For checking onjects in array, you need to use toContainEqual()

    9)expect(somevar).toMatch(regexp|string|object)


    7)expect(promise).resolves.
        after this you can use any jest matchers, like -
        expect(promise).resolves.toBe()

        this returns promise and make sure that you return this assertion from your test , if you are testing asynchronous code 
    8)expect(promise).reject()
        expect(promise).resolves.toBe()
        expect(promise).rejects.toBeInstanceof(errorClass) //rejects with object that is instance of given class

    9)expect(value).toBeUndefined()
        asserts that value is undefined

    9)assertins on spies -
        expect(spy).toBeCalled()
        expect(spy).toBeCalledTimes(number)
        expect(spy).toBeCalledWith(argList)


    



assertion count -
    1)expect.assertions(3) -
        Test will only pass if atleast 3 assertions are executed
    2)expect.hasAssertions() - Test will pass if it has atleast 1 assertions


Methods on it and describe - 
    a)describe.concurrent()
    b)it.concurrent()

cmd flags -
    vitest --global
        makes the things like expect,it,describe avalible without import as global variables. but importing them gives better
            IDE support
    vites --run
        instead of getting into watch mode, runs it once only


Mocks and Spies -

    a)jest.fn(), vi.fn() - Optionally you can also provide a callback argument, which is implementation.
        creates a empty mock function. there are various methods which can be used to do following -
            a)mockReturnValues, mockResolvedValues, mockReturnValueOnce
            b)mockImplementation,mockImplementationOnce
            c)reset/restore/clear mock
            d)to get hold of arguments,returnValue, this etc - mockFn.mock


        When you call jest.module('path') all returned functions are replaced by empty mocks. you can use all functions described above on them.
            see SCreenshotListEntry file for details

    b)jest.mock('pathToModuke') - mocks built in nodemodules,thrid part modules and user defined modules. by default all exports are replaced by empty
        mock(or spies). however you xan also provide implementation of what is returned from module. as second argument you can provide  a callback, whatever
        this callback returns, is returned from module
    Assertions on mocks -
        a)expect(mock).toBeCalled()
        a)expect(mock).toBeCalledWith(arguments)
        a)expect(mock).toBeCalledTimes(number)


Extra from Course -
    a)jest.createMockFromModule(moduleName) - used when you want to implement your manual mock but want to inherit some functionality from orignal mock.
        so that you do not need to define all functions.but note that functions will be mocked and not actual implementation.
        https://jestjs.io/docs/manual-mocks
    b)jest.requireActual(moduleName) - Returns the actual module instead of a mock, bypassing all checks on whether the module should receive a mock
        implementation or not.
        uses -
            a)can be used to orignal function while defining mocks in __mocks__ folder.
            b)can use used to get actual module implementation in file where you have already mocked the module.
    c)jest.doMock - will not mock jest.mock to top of your file
        https://github.com/kentcdodds/how-jest-mocking-works

        vi.mock, but it's not hoisted to the top of the file, so you can reference variables in the global file scope. The next dynamic import of the 
            module will be mocked.


    TS types -
        a)jest.Mocked<Source> - gives type to mocked module
        b)jest.mocked(source,options)
        c)Jest.Mock<T>
