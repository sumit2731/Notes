Module content -
    a)diffrent types of data in images And Containers
    b)dive into concept called volumne
    c)arguments and envirenment variables.

lecture 43 -
    Slide 1 shows different types of data. for permanent data, that we need to read and write. we use concept called volumnes.
    
    see slide 2 -
    Application run time data is stored in container. And when I say stored in containers,not in images, I'm talking about this 
        extra layer,which is added by Docker on top of our image,which then actually makes up that container.And this extra 
        layer basically is a bit of a logic you could say,that is aware of the image,is aware of the file system of the image,
        and kind of mirrors that file system without copying it.But then that's the extra thing,here, Docker then actually also
        has read-write access,and is able to manipulate that file's system.Without changing it in the image,just by changing it
        in that extra layer.And behind the scenes,this is managed in a very efficient way,where Docker basically keeps track of
        the changes made by the container,and derives the final file system,by taking the file system in the image,and combining
        it with the changes stored in that read-write layer.

lecture 44, 45 -

    here app in folder code1 is explained. this app shows a page which ask for title and text. you click on save.
    let's say title is title1, now a file with name title1.txt  will be created in folder temp. now if file with 
    same name does not exist in feedback folder, it is copied there. if it exist there user is redirect to page,
    which shows him that file already exists(pages/exists.html).

    also you can see the file store in feedback by vissitng the route - localhost:3000/feedback/text1.txt

lecture 46 -
    
    so problem that we are trying to solve is upon deleting a container filesystem of that container is also deleted. so
    it means any changes made on top of image by this container is also lost.but we would like to keep those changes, even
    after container is destroyed.

    note that upon stopping the container file system is not deleted , so when we start the container again , those changes
    are there.


lecture 47(Introducing volumnes) -

    see slide 3
    Volumes are folders on your host machine,so not in the container,not in the image,but on your host machine hard drive,
    which are mounted,which basically means, made available or mapped,into containers.If you add a volume to a container,
    the volume will not be removed,when a container is removed,



lecture 48,49(types of volumes) -

    In lecture 48 we setup the annonymous volume in our dockerFile. see code1 folder. then we noticed that this volume is 
     getting destroyed when we stop the container if we use --rm flag while starting container. see dockerFile of code1 to 
     know more about annonymous volume. we will see usecase for annonymous volumne later in course.

     refer to this slide to see when annonymous volume is getting destroyed -

     https://www.udemy.com/course/docker-kubernetes-the-practical-guide/learn/lecture/22181286#questions


    see slide 4 to see types of volumes. then we had a look at named volumes(refer to folder code2).

    there is named volumes also, if we use those then volume is not destroyed when we remove or stop the container. the file 
     is persist on our local filesystem, when we start the container again and link same volume with docker while starting it, 
     then those files are copied back into container as both locations are mapped to each other via volums.So named volumes are
     great for data which should be persistent,and that's important,which you don't need to edit or view directly,because you 
     don't really have access to that folder on your host machine.As I just said, it's hidden somewhere managed by Docker,and 
     it's hard to find out where it is. And it's not meant to be edited by you.I'll come back to an option which you can edit 
     later.


    we cannot create namd volume inside of docker file. we need to create them when we run container.

    comamnd for that is -

    docker run -v nameofVolumne:pathInContanerFileSystem

    so we ran this command - 
        docker run -p 3000:80 -d --rm --name feedback-app -v feedback:/app/feedback feedback-node:volumes

    saved a file. stopped the container, then saw volumes using -
        docker volume ls

    we can see that volume is still there.

    then we created a new container but gave it same volume we can see that we can still access files that were stored in older 
    container.

    docker run -p 3000:80 -d --rm --name feedback-app-new -v feedback:/app/feedback feedback-node:volumes

    here we chnaged the name of container but since old storage is lined old filesystem is made avalible inside  container.


lecture 51(bind mounts) -

    Bind mounts have some similarities with volumes,but there is one key difference.Where volumes are managed by Docker,and we don't really
     know where on our host machine file system they are.For bind mounts, we do know it.Because for bind mounts, we, as a developer,set the
     path to which the container internal path should be mapped on our host machine.So here, we're fully aware off the path on our localhost
     machine.

     so if change a file in localSystem, it is imemdiatellly refleted in contianer fileSystem.


     how to setup bind mount -
        -v "absolutePathInFileSystem:absolePathInDockerFileSystem"

     docker run -v feedback:/app/feedback -v "/Users/susood/Desktop/notes/notes/Lectures/Maxudemy Courses/Docker & Kubernetes/3)Managing_Data_And_Working_With_Volumes/code2/Dockerfile:/app" feedback-node

     once we run the container it crashes, when we read the log then it throws error -"cannot find express", it means we do not have node_modules
     in container.

lecture 53(combining and merging volumes) -

    reason for above behaviour is docker is overriding the container file system with local file system because of bind mount.
    initially we had node_modules in container(becuas while cretaing image we run that command), later when we do bind mount we
    overwrite all file in ctianer with our local file system. and our local folder is not having node_modules folder. hence error.


    see slide 5 to understand how container intercats with volume/bindMount.

    when we connect some path in contianer with path on local file system. these can happen -

    a)we already had some file in container path, in that case they will now also exist in outside volume i.e local file system.
        if we write new files, then they are also copied to local file system.

    b)if container starts and it does not have any file in path mentioned by volume, but volume has some data, thne that is copied in
        conatiner path.

    but now we files in local system as well as in container.And now the good thing isthat Docker does not start overwriting our local files
        on our host machine.This would be pretty bad,if Docker would be doing that, right.We could delete a lot of important things. so
        docker file system is overwriten by local file system.


    Now to solve this problem, we kind of need to tell Docker,that there are certain parts in its internal file system, which should not be 
    overwritten from outside in case we have such a clash as we have it here. And this can be achieved with anonymous volume. here we
    specify annonymous volume while creating container.(we can also sepcify annonymous volume in dockerFile). so we run this -

    docker run -d --rm -p 3000:80 --name feedback-app -v feedback:/app/feedback -v "/Users/susood/Desktop/notes/notes/Lectures/Maxudemy Courses/Docker & Kubernetes/3)Managing_Data_And_Working_With_Volumes/code2:/app" -v /app/node_modules feedback-node

    docker evaluates all volumes that you set on container. if there are clashes,docker has simple rule - when multiple volumes are mapped to 
    same path, more specific path wins. so here node_modules is being mapped by 2 volumes one(bind mount) has this path - /app

    but other(annonymous volume) has this path  - app/node_modules

    second path is more specifc so, node_modules folder is mapped by it.The node modules folder will survive,it will overwrite the folder 
    that's coming in from outside because of bind mount,and from outside no node modules folder comes,and therefore container node modules
    folder overwrites the non existent node modules folder.

    you think it like that app folder is mapped by bind mount but node_modules is binded by annonymous volume(as path of annonymous volume
    is more specifc), so node_modules is not not overwritten by content of bind mount.


    now with bind moount, we have access to local file system, if we chnage anything there chnage is reflected in container.

    so annonymous volume can be used to lock in data that already exist in container.They can be useful for avoiding that this data then gets
    overwritten by another volume.


lecture 54(using nodemon) -

    so if our server is running if we chnage html file then chnage feflects imemdiately but if chnage js file then we need to 
     stop server and run it again. In case of docker we can stop container and run it again, then our cnages will reflect.

    but we use nodemon then it automaticallt restarts the server if files are chnaged, so here we used that. so now just chnage 
    the file we will see changes immeiately.


    In case you are using windows especially if you are using wsl to run docker on windows, this might not work.reason is while using wsl2,
    you should store your project and project files in linux file system.see attcahed doc to read it.



Lectures 55(Summary) -

    one more usecase of annonymous volumes -

    docker doesn't have to store all the data inside of the container and doesn't have to manage all the data inside of this container read
    write layer.But that instead it can outsource certain data to your host machine file system.And this can also help with performance and
    efficiency.So that's why anonymous modules can be worth a closer look.
    And in this example,we could consider creating another anonymous volume,for the temp folder.for tiny performance improvements,
    it can be worth mapping this temp folder to an anonymous volume so the data managed in there is not managed in the docker container 
    anymore,but actually well outsourced to the host file system.

    named volume cannot be created via dockerFile, they have to b created via -v flag while creating container.there is separate command
    to remove named volumes tat we will see later.

    bind mounts canot be cleared via docker file, you have to delete the files in your local file system. also intention of bind mount is
    that you are able to chnage files in your local file system and they should be avalible inside container without image rebuilding.


Lectures 56(Look at Read-Only Volume) -
    intention of usng bind mount was that we want to change code in our local and it should reflect in container. so we can mark this volume
    as read only so that we do not accidantly chnage anything from container. but we need write permission for feedback and temp folder.earlier
    we ran this command -

    docker run -d --rm -p 3000:80 --name feedback-app -v feedback:/app/feedback -v "$(pwd):/code3:/app" -v /app/node_modules feedback-node

    now we want to block write access of docker for bind mount. but provide write access for feedback and temp. so there we ca use strategy
    that we alraedy used i.e map annonymous volume to these locations and there use more specific path.with feedback we have already attached
    named volumne, so there adding we have write access, we just need to add annonymous volume for temp folder. so now we ran -

    docker run -d --rm -p 3000:80 --name feedback-app -v feedback:/app/feedback -v "$(pwd):/app:ro" -v /app/node_modules -v /app/temp feedback-node



Lecture 57(managing docker volumes)

    here we saw basic commands to manage docker volumes. commands are listed in main notes.