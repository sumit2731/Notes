1)Promise defination.Internal properties of promise(cannot be accessd from outside) - 
    State - Pending, Resolved, Rejected
    Result - unefined, value, error

2)Promise is resolved or rejected only once, further calls to resolved and rejected are ignored.

3)Resolved and rejected expect 1(or none) arguments, any additional arguments are ignored.

4)catch should be called with object that inherts from Error Object.

5)consumer methods - 
    a)then - 2 methods first for resolve and second for rejected.
        if only interested in resolved state - p1.then(f1)
        if only resulted in catch state - p1.then(null, f1)
    b)catch - takes function which will only be called when promise is rejected.
        p1.then(null, f1) => p1.catch(f1)

    c)finally - executed in both cases when promise is resolved or rejected. 
        
        a)A finally handler has no arguments. In finally we don’t know whether the promise is successful or
         not. That’s all right, as our task is usually to perform “general” finalizing procedures.

        b)A finally handler passes through results and errors to the next handler.

            new Promise((resolve, reject) => {
                setTimeout(() => resolve("result"), 2000)
            })
            .finally(() => alert("Promise ready"))
            .then(result => alert(result)); // <-- .then handles the result
            .catch(err => alert(err));  // <-- .catch handles the error object

6)We can attach handlers to settled promises, they will be called immediately.

6)advantages of promises over callback. at the end of blog, in table.

8)Promise question in last.