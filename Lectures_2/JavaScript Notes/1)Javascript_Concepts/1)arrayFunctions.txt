Modifies Orignal Array -

    1)copyWithin() - arr.copyWithin(target[, start[, end]])

    1)fill()* - The fill() method changes all elements in an array to a static value, from a start index (default 0) to an end 
        index (default array.length). It returns the modified array.

        arr.fill(value[, start[, end]])

        Parameters -

            value - Value to fill the array with. (Note all elements in the array will be this exact value.)
            start (Optional) Start index, default 0.
            end (Optional) End index, default arr.length.

        Return -
            The modified array, filled with value.

        If start is negative, it is treated as array.length + start.
        If end is negative, it is treated as array.length + end.
        fill is intentionally generic: it does not require that its this value be an Array object.
        fill is a mutator method: it will change the array itself and return it, not a copy of it.
        If the first parameter is an object, each slot in the array will reference that object.

    2)splice()* -This method changes the contents of an array by removing or replacing existing elements and/or adding new elements in place.
        let arrDeletedItems = array.splice(start[, deleteCount[, item1[, item2[, ...]]]])

        start - If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, 
            meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.)

        Retrun Value- An array containing the deleted elements.

   

Methods that do not modify the orignal Array -

    1)Array.prototype.concat()*

    2)entries() - thi method returns a new Array Iterator object that contains the key/value pairs for each index in the array.

    3)every()* - The every() method tests whether all elements in the array pass the test implemented by the provided function. 
        It returns a Boolean value.

        Syntax - arr.every(callback(element[, index[, array]])[, thisArg])

        Return Value - boolean 
            true if the callback function returns a truthy value for every array element. Otherwise, false.

        
        The range of elements processed by every is set before the first invocation of callback. Therefore, callback will not run on 
            elements that are appended to the array after the call to every begins. If existing elements of the array are changed, 
            their value as passed to callback will be the value at the time every visits them. Elements that are deleted are not 
            visited. exmaple on mdn docs proove this same point.

    4)Array.prototype.filter()* - callback is invoked only for indexes of the array which have assigned values; it is not invoked 
        for indexes which have been deleted or which have never been assigned values.

        The range of elements processed by filter() is set before the first invocation of callback. 
        a)Elements which are appended to the array (from callback) after the call to filter() begins will not be visited by callback. 
        b)If existing elements of the array are changed, their value as passed to callback will be the value at the time map visits them.
        c)If existing elements of the array are deleted in the same way they will not be visited.
            exmaple on mdn docs proove this same point.
    
    5)Array.prototype.find()* - callback is invoked for every index of the array, not just those with assigned values. This means it may
        be less efficient for sparse arrays, compared to methods that only visit assigned values.

        The find method does not mutate the array on which it is called, but the function provided to callback can. If so, the elements 
        processed by find are set before the first invocation of callback. Therefore:

        a)callback will not visit any elements added to the array after the call to find begins.
        b)If an existing, yet-unvisited element of the array is changed by callback, its value passed to the callback will be the value 
            at the time find visits that element's index.
        c)Elements that are deleted are still visited.

    6)Array.prototype.find()* - 
        arr.findIndex(callback( element[, index[, array]] )[, thisArg])
        if array are modified in iteration same rule as find are folowed.

    7)Array.prototype.flat() -
        The flat() method creates a new array with all sub-array elements concatenated into it recursively up to the specified depth.

    1)slice(also exist on strigs) -The slice() method returns a shallow copy of a portion of an array into a new array object 
        selected from begin to end (end not included) where begin and end represent the index of items in that array. 
        The original array will not be modified.

        Signature - arr.slice([start[, end]])

        both start end end are optional. A negative index can be used, indicating an offset from the end of the sequence.
        if starting index is larger than indexes avalible then emty array is returned.
        
        
            let arr = [0,1,2,3,4,5]
            slice(1,4); // [1,2,3]
            slice(-3,-1); //[3,4]
            slice(1,-3);//[1,2]
            slice(1,-5);// []

        return value - Array

    2)reduce- This method executes a reducer function (that you provide) on each element of the array, resulting in single output value.

        
        arr.reduce(callback( accumulator, currentValue[, index[, array]] )[, initialValue])

        The reducer function takes four arguments:

            Accumulator (acc)
            Current Value (cur)
            Current Index (idx)
            Source Array (src)
        
        The accumulator accumulates callback's return values. It is the accumulated value previously returned in the last invocation
        of the callbackâ€”or initialValue, if it was supplied (see below). if it is not supplied then in first iteration,
        accumulator's value is equal to current value of array.
        
        Your reducer function's returned value is assigned to the accumulator, whose value is remembered across each iteration
        throughout the array, and ultimately becomes the final, single resulting value.

        Return Value - value that is returned(accunulator) in last iteration


    3)indexOf - The indexOf() method returns the first index at which a given element can be found in the array, or -1 if it is 
        not present.indexOf() compares searchElement to elements of the Array using strict equality (the same method used by 
        the === or triple-equals operator)

        Signature - arr.indexOf(searchElement[, fromIndex])
        fromIndex - The index to start the search at.If the provided index value is a negative number, it is taken as the offset 
            from the end of the array. Note: if the provided index is negative, the array is still searched from front to back. 
            If the provided index is 0, then the whole array will be searched. Default: 0 (entire array is searched).

        Returns - index of element

    4)Array.from - The Array.from() static method creates a new, shallow-copied Array instance from an array-like or iterable
        object.Another application for the Array.from method is a scenario wherein you want to create a new array and fill it with 
        elements.
        
        Signature - Array.from(arrayLike [, mapFn [, thisArg]])

    5)Array.join - The join() method creates and returns a new string by concatenating all of the elements in an array (or an array-like 
        object), separated by commas or a specified separator string. If the array has only one item, then that item will be 
        returned without using the separator.

        Signature - arr.join([separator])

        separator- (Optional)Specifies a string to separate each pair of adjacent elements of the array. The separator is converted to 
            a string if necessary. If omitted, the array elements are separated with a comma (","). If separator is an empty string, 
            all elements are joined without any characters in between them.

        const elements = ['Fire', 'Air', 'Water'];

        console.log(elements.join());
        // expected output: "Fire,Air,Water"

        console.log(elements.join(''));
        // expected output: "FireAirWater"

        console.log(elements.join('-'));
        // expected output: "Fire-Air-Water"




