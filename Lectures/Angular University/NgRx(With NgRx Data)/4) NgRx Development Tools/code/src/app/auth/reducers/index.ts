import {
  ActionReducer,
  ActionReducerMap,
  createFeatureSelector,
  createSelector,
  MetaReducer,
  createReducer,
  on
} from '@ngrx/store';

import { environment } from "../../../environments/environment";
import { User } from '../model/user.model';
import { AuthActions } from "../action.type";

/* 
Because we are inisde the authentication module, thiss not correspond to the global application state. Instead what we should 
  have here is the authentication state.So this is the state inside the store that gets managed by this particular module, 
the authentication module. Authentication State corrosponds to the data is stored inside the "auth" property of the store.

so auth property will be a object with property user.
*/
export interface AuthState {
  user:User
}
/* 
THis is intial value of auth property of state when app loads.
*/
export const initialAuthState: AuthState = {
  user:undefined
};

/* 
By the way we won't be using here to reduceMap that was generated by our scaffolding command.
We are going to be using it later on in another part of the course.

*/

// export const reducers: ActionReducerMap<State> = {

// };

/* 
Very similar way to our action creators.We are going to be defining here the reducer using an ngRx utility 
  called Createreducer.So these create reducer.It's just the simplified way of creating our reducer function.

So the first argument that we need to pass in here is the initial value of the authentication state.means value
  of Authentication state when app loads

As the next arguments of createReducer, we are going to be specifying here smaller functions that are going to tell the store
  how to react to a particular action. so we use on api from ngRx. first argument to on is action to which we are reacting to.

here we want to react to login action, So what should we do in response to a log in?So in response to logging we need to 
  create a new authentication state.We can do so by defining here a small function that takes as the first argument the 
  state and as the second argument the action. the output should be the new version of the authentication state.

So let's summarize what we have created here at this point.We have created here a reduced function that defines the initial 
  authentication state of our application.And it also defines what the store should do in response to a log in action.

So now that we have defined our reducer we just need to plug it into ngRx and have it handle logging actions. for that
we pass this reducer as a second argument to forFeature method of StoreModule in authModule.

action is a object like this-
    { 
      type: "[Login Page] User Login"
      user: {id: 1, email: "test@angular-university.io"}
    }

Callback function passed to 'on' is called whenever action is dispatched. this function returns new state.

A reduced function always returns a new copy of the state and never mutates the existing state.
  Otherwise our time travelling debugger that we're going to be using later on in the course would not work.
*/

export const authReducer = createReducer(initialAuthState,
  on(AuthActions.login, (state, action) => {
    return { user: action.user };
  }),
  on(AuthActions.logout,(state,action) => {
    return {user: undefined}
  })
);

// function authReducer(state, action): State {
//   return new State;
// }

//export const metaReducers: MetaReducer<State>[] = !environment.production ? [] : [];
