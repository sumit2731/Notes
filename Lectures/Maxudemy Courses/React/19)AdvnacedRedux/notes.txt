1)slide 1-
    here is one super important rule.Your reducer functions must be pure, side-effect free, and synchronous.So your reducer 
    functions should take some input in the case of the Redux reducer,the old state and the action,and then produce some output.
    It has nothing to do with redux,but it just general reducer concept that you have a pure,side effects synchronous function
    that takes input and produces some output.And for the same input,for the same values,it will always produce the same output,
    without any side effects that happen along the way without any asynchronous code that blocks it.No code of that kind must be 
    part of your reducer functions.

    important question is when working with redux, when we dispatch some action that would involve a side effect, like HTTP request
     that should be sent,where should we then put the side effect code?


 options are -
    
    1)We can put our side effects possibly asynchronous code directly into the component with user fact for example, so just as
     we did it before in this course,and then we only dispatch an action once that side effect is done so Redux doesn't know 
     anything about that side effect,

    2)we write our own action creator functions,so we don't use the automatically generated ones redux toolkit gives us but instead
     we write our own action creators.And it turns out that for those action creators redux actually has a solution that allows us
      to perform side effects and run asynchronous tasks as part of this action creators without changing the reducer function.

we are going to have a look at both approaches in this course section.


2)in code folder 1, we just prepared a application with redux code, that is what we alrrasy did in last section.

3)In lecture 256, we discussed problem about where we should do that data transaformation, we did it in component and discused
    it drawbacks-
        
        1)If same action needs to be dispatched in multiple components, then that data transaformation logic needs to be copied
            everywhere. we can solve this by outsouurce this transaformation logic into a function.
        2)even if we solve problem 1, our reducer are now ot doing lot of work just storing the data that they get.
        That can be fine and if that's your personal preference that's not necessarily bad but it's not the main idea behind using
         Redux. see slide 2. here code that we have now is synchronous and side effect free and we have written it inside component
         and not reducer.but what would be better way of doing it then? Because we need to prepare it before we send it to Firebase
         because we can send the request from inside the reducer.


4)so our first option is to move data transaformation logic into reducer and make http request in useEffect when state have been
    updated.see code in app.js. here when we get state slice form store, a subscription is setup, whenever state changes component
    function is re executed.since we have added cart as dependency of useEffect, useEffect will be executed agaim. this helps
    us to create lean components and fat reducers with all state transaformation logic and perform all the side effect logic,
    that might depend upon our store.

    So that is a very, very nice and that's a very good way of having our side effect logic in a component and keeping all our 
    data transformation logic inside of a Reducer,which is where we typically wanna have it when working with Redux.

    see code in folder 2 for this.