1)  Different Syntaxes
    { provide: Engine, useClass: OtherEngine }

This is super powerful, because this allows us not only to prevent name collisions, we can also create a type as interface
 and bind it to a concrete implementation.In addition to that, we can swap out the actual dependency for a token in a
 single place without touching any other code








1)

    @Component({
        ..
        providers: [MyService] // creates a provider for MyService
    })

    It can also be expressed like this-

    @Component({
        ...
        providers: [
            provide(MyService, { useClass: MyService })
        ]
    })

    This enables us to create objects of different types, or even use completely different ways of constructing 
        objects like using a factory function, or simply injecting a value.

    // creates instance of MyOtherService
    provide(MyService, { useClass: MyOtherService })

    // uses a factory function to create a dependency
    provide(MyService, { useFactory: () => return { foo: 'bar' } })

    // injects a simple value
    provide(MyService, { useValue: true })

    we can also specify all these like this-

    providers: [
    { provide: MyService, useClass: MyOtherService }
  ]